<?php

namespace eProcess\EntityBundle\Entity;

use \PDO;
use eProcess\SecurityBundle\Constantes\TypeDate;
use DateTime;
use eProcess\SecurityBundle\Constantes\TypeProfile;
use eProcess\SecurityBundle\Constantes\EtapeFacture;

/**
 * FactureTable
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class FactureTable extends \Doctrine\ORM\EntityTable {

    /**
     * getNextNumber : fonction de génération des numero  séquentielle des factures arrivées
     * 
     */
    public function getNextNumber() {

        // la requete sql à exécuter sous forme de chaine de caractère.
        $sql = ' select max(cast(f.ordreArrive as signed)) from facture f';

        // transformation de la chaine de caractère sql sous form de requete exécutable
        $statment = $this->_em->getConnection()->prepare($sql);

        // execution de la requete sql dans un bloc try and catch
        try {
            // execution de la requete
            $statment->execute();
            // recuperation du resultat sous forme d'un tableau de reel
            $result = $statment->fetch(PDO::FETCH_NUM);
        } catch (\Exception $e) {
            // en cas d'erreur qu'on affich e l'erreur
            var_dump($e);
            exit;
        }
        // si le tableau est vide on renvoi 1 si non on incrémente le  resultat de 1
        $result = (count($result) > 0) ? ($result[0] + 1) : 1;
        // on formate le resultat sur 6 positions dont les espaces vides de gauche sont remplis par 0
        return str_pad($result, 6, '0', STR_PAD_LEFT);
    }

    /**
     * findByDateReception : fonction de recuperation des facture arrivées entre deux dates
     * 
     * @param type $debut
     * @param type $fin
     */
    public function findByDateReception($debut = '', $fin = '') {

        // construction de la racine de la requete
        $queryBuilder = $this->createQueryBuilder('f');
        $queryBuilder->where('1 = 1');

        $dateDeb = \DateTime::createFromFormat('d-m-Y', $debut);
        $dateFin = \DateTime::createFromFormat('d-m-Y', $fin);

        if (!$debut && !$fin) {
            $dateDeb = new DateTime();
            $dateFin = new DateTime();
        }
        if ($debut) {
            $dateDeb->setTime(0, 0, 0);
            $queryBuilder->andWhere('f.dateArrive >= :dateDeb')
                    ->setParameter('dateDeb', $dateDeb);
        }
        if ($fin) {
            $dateFin->setTime(23, 59, 59);
            $queryBuilder->andWhere('f.dateArrive <= :dateFin')
                    ->setParameter('dateFin', $dateFin);
        }
        $queryBuilder->orderBy('f.dateArrive', 'ASC');

//        var_dump($queryBuilder->getDQL()); exit;
        return $queryBuilder->getQuery()->getResult();
    }

    public function findByDateTraitement($debut = '', $fin = '') {

        $dateDeb = implode('-', array_reverse(explode('-', $debut))) . '00:00:00';
        $dateFin = implode('-', array_reverse(explode('-', $fin))) . ' 23:59:59';


        // construction de la racine de la requete
        $queryBuilder = $this->createQueryBuilder('f');
        $queryBuilder->where('1 = 1');

//        $dateDeb = \DateTime::createFromFormat('d-m-Y', $debut);
//        $dateFin = \DateTime::createFromFormat('d-m-Y', $fin);
//
//        if (!$dateDeb && !$dateFin) {
//            $dateDeb = new DateTime();
//            $dateFin = new DateTime();
//        }
        if ($debut) {
            $queryBuilder->andWhere('f.dateTraitement >= \'' . $dateDeb . '\' ');
        }
        if ($fin) {
            $queryBuilder->andWhere('f.dateTraitement <= \'' . $dateFin . '\' ');
        }




        $queryBuilder->orderBy('f.dateTraitement', 'ASC');

//        var_dump($queryBuilder->getDQL()); exit;
        return $queryBuilder->getQuery()->getResult();
    }

    public function getTraitementJournee() {
        
    }

    /**
     *  findMultiCritere : fonction de recherche multicritère des factures : elle n'es plus utilisées
     * 
     * @param type $idFour
     * @param type $idBon
     * @param type $etape
     * @param type $montMin
     * @param type $montMax
     * @param type $devise
     * @param type $debut
     * @param type $fin
     * @param type $typeDate
     * @return type
     */
    public function findMultiCritere($idFour = 0, $idBon = 0, $etape = 0, $montMin = 0, $montMax = 0, $devise = '', $debut = '', $fin = '', $typeDate = 0) {


        $sql = ' select'
                . ' fct.id            as id, '
                . ' fct.ordreArrive   as ordreArrive, '
                . ' a.objet           as objet, '
                . ' a.montant         as montant , '
                . ' a.devise          as devise, '
                . ' fct.etape         as etape, '
                . ' a.facture_id         as factureId '
                . ' from facture fct  inner join achat a on fct.id = a.facture_id ';

        if ($idFour) {
            $sql .=' inner join fournisseur f   on f.id = a.fournisseur_id ';
        }
        // controle au cas ou rien n'est saisie
        if (!$etape && !$idFour && !$idBon && !$montMin && !$montMax && !$debut && !$fin && !$devise) {
            $sql .=' where 1 != 1';
        } else {
            $sql .=' where 1 = 1 ';
        }

        if ($idFour) {
            $sql .=' and  f.id =  '.$idFour ;
        }

        if ($etape) {
            $sql .=' and  fct.etape = ' . $etape;
        }

        if ($montMin) {
            $sql .=" and CAST(replace(a.montant,' ','') AS SIGNED) >= " . $montMin;
        }

        if ($montMax) {
            $sql .=" and CAST(replace(a.montant,' ','') AS SIGNED) <= " . $montMax;
        }


        if ($devise) {
            $sql .=" and a.devise = '" . $devise . "'";
        }

        if ($debut) {
            $dateDebut = implode('-', array_reverse(explode('-', $debut))) . ' 00:00:00';
            if ($typeDate == TypeDate::DATE_CREATION) {
                $sql .=' and fct.dateCreation >= \'' . $dateDebut . '\' ';
            } else if ($typeDate == TypeDate::DATE_ARRIVE) {
                $sql .=' and fct.dateArrive >= \'' . $dateDebut . '\' ';
            } else if ($typeDate == TypeDate::DATE_TRAITEMENT) {
                $sql .=' and fct.dateTraitement >= \'' . $dateDebut . '\'  ';
            } else if ($typeDate == TypeDate::DATE_AUTORISE) {
                $sql .=' and fct.dateActivation >= \'' . $dateDebut . '\'';
            }
        }

        if ($fin) {
            $dateFin = implode('-', array_reverse(explode('-', $fin))) . ' 23:59:59';

            if ($typeDate == TypeDate::DATE_CREATION) {
                $sql .=' and fct.dateCreation <= \'' . $dateFin . '\'';
                var_dump($sql);
                exit;
            } else if ($typeDate == TypeDate::DATE_ARRIVE) {
                $sql .=' and fct.dateArrive <= \'' . $dateFin . '\'';
            } else if ($typeDate == TypeDate::DATE_TRAITEMENT) {
                $sql .=' and fct.dateTraitement <= \'' . $dateFin . '\'';
            } else if ($typeDate == TypeDate::DATE_AUTORISE) {
                $sql .=' and fct.dateActivation <= \'' . $dateFin . '\'';
            }
        }


        $connection = $this->_em->getConnection();
        $statement = $connection->prepare($sql);
        $statement->execute();
        
        return $statement->fetchAll();
    }

    public function getFactureArrayEtape($arrayEtape) {
        $result = array();
        $condition = '';

        foreach ($arrayEtape as $etape) {
            $condition.=" OR f.etape= '" . $etape . "'";
        }

        // au cas où il existe une valeur, pour les differents etape
        //  de la facture, on recupere les factures qui sont dans ces etats
        if (count($arrayEtape) > 0) {
            $qb = $this->createQueryBuilder('f');
//            $stringEtape = implode(',', $arrayEtape);
            $qb->where('f.etape = -1  ' . $condition . '');
//            $qb->where('f.etape = 0  in (' . $stringEtape . ')');
//            var_dump($qb->getDQL());
//            exit;
            $result = $qb->getQuery()->getResult();
        }


        return $result;
    }

    /**
     * getStatistiqueEtape: fonction qui  recupere pour chaque profil, le nobre de facture par etape qui se trouve à son niveau 
     * 
     * @param string $codeProfile
     * @return Json
     */
    public function getStatistiqueEtape($codeProfile) {

        $etape = array();
        $nbreFact = array();

        // recuperation des etape des factures correspondant à un profil d'utilisateur
        if ($codeProfile == TypeProfile::RECEPTION) {
            $etape[] = EtapeFacture::FCT_ARRIVE_RECEPTION;
            $etape[] = EtapeFacture::FCT_ENVOYE_EBS;
        } else if ($codeProfile == TypeProfile::EBS) {
            $etape[] = EtapeFacture::FCT_ARRIVE_EBS;
            $etape[] = EtapeFacture::FCT_TRAITE_EBS;
            $etape[] = EtapeFacture::FCT_PROBLEME_EBS;
            $etape[] = EtapeFacture::FCT_REJETE_OPS;
            $etape[] = EtapeFacture::FCT_ENVOYE_OPS;
        } else if ($codeProfile == TypeProfile::OPERATIONS) {
            $etape[] = EtapeFacture::FCT_ARRIVE_OPS;
            $etape[] = EtapeFacture::FCT_PROBLEME_OPS;
            $etape[] = EtapeFacture::FCT_VALIDE_OPS;
        }


        foreach ($etape as $e) {
            $indice = EtapeFacture::readEtape($e);
            $nbreFact[$indice] = count($this->findByEtape($e));
        }
                
         $result['key'] =  array_keys($nbreFact)    ;  
         $result['value'] =  array_values($nbreFact);     
//        $string = htmlspecialchars_decode( str_replace('"', "'",json_encode($nbreFact, true)));
//        $string = str_replace('"', " ",$string);
//        var_dump(json_encode($result));exit;
         
         return json_encode($result);
    }

}
